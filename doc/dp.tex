\documentclass[a4paper,11pt]{report}
\usepackage{a4wide}
\usepackage[latin2]{inputenc}
\usepackage[
  bookmarks=true,
  bookmarksopen=true,
  colorlinks=false,
  urlbordercolor={0 0 0},
  pdfhighlight=/I,
  pdftitle=,
  pdfauthor=Petr\ Machata,
  pdfstartview=FitH,
  bookmarksopenlevel=2
  ]{hyperref}
\usepackage{subscript}
\pagestyle{empty}
\topmargin 0in
\begin{document}

\title{Construction of GNU Compiler Collection Frontend}
\author{Petr Machata\\
  \texttt{xmacha31@stud.fit.vutbr.cz}}
\date{2006-09-08}
\maketitle

\def\program#1{{\tt\begin{tabbing}#1\end{tabbing}}}
\def\mychapter#1{{\Huge \bf \vspace{1em}#1}\vspace{1.0em}}
\def\mysection#1{{\Large \bf \vspace{1em}#1}\vspace{1.0em}}
\def\mysubsection#1{{\large \bf \vspace{1em}#1}\vspace{1.0em}}

\def\Algol{{\sc Algol}\space}

% ====================================================================

\chapter*{Prohlá¹ení}

Prohla¹uji ¾e jsem tuto bakaláøskou práci vypracoval sám pod odborným
vedením Ing. Luká¹e Szemly.  Ve¹keré prameny, z nich¾ jsem pøi práci
èerpal, jsou øádnì citovány, a v pøíloze uvedeny.

% ====================================================================

\chapter*{Acknowledgements}

Thanks to... (FIT BUT that they gave up their rights)

% ====================================================================

\chapter*{Abstrakt}

\mysection{Klíèová slova}

% ====================================================================

\chapter*{Abstract}

\mysection{Key words}

% ====================================================================

\chapter{Introduction}

Describe what this thesis is about, summarize chapters, provide
insight to how to read it.

\chapter{Why GCC, Why Now}

(Reference: Tom Tromey's Java paper) Summarize options available when
one writes new language.  Interpreters and compilers, hand-rolling
compiler, compiling via C (this sucks mostly because C compiler has to
recover the higher level model from C, which of course isn't possible;
and debugging--GCC will preserve symbol names where necessary, while
in C, you'd have to mangle them without chance to give a clue to
target C compiler (you want to emit #line directives to point the user
to the place where the error originated, and in debugger you have no
way to hide the fact that you are going through C)), compiling via GCC
(what if it's dynamic language, what if static).

Personal opinions aside, writing GCC frontend is probably best choice.
GCC is ported to dozens of platforms, has tons of optimizations, has
necessary community, corporation and academia drive, and finally
writing such frontend isn't nearly as difficult as rolling your own
backend (fingers crossed it's true).

Describe briefly that the author has written \Algol 60 parser to get
himself familiar with the stuff he describes.  Maybe drop a few notes
about how the parser (independent from GCC) and GCC frontend got
joined.

\chapter{GCC Architecture}

How does GCC work.  What's driver, what's the frontend proper.  Bird's
eye view of compilation passes, internal structure, references to
other documents with more detailed description.  Main source will be
Diego Novillo's OLS paper.  Mention garbage collector (only mention).
Also
mention hooks, but don't go into depth (go as far as Tom Tromey's
Linux Journal article).

Mention that there are two approaches: targeting GENERIC, and using
GENERIC as AST rep.  This work aims at the former scenario.  Under
this setup, there are four levels actually: your parser, GCC frontend,
GCC middleend, GCC backend.  The frontend of the parser is completely
independent of GCC, backend of the parser is frontend of the GCC.
With the latter approach, one defines special tree codes.

\chapter[Hello World]{Hello, World!}

What's Make-lang.in, config-lang.in, lang-specs.h, algol60.texi.

Compilation process: why language subdirectory, what happens with
Make-lang.in and config-lang.in, what's bootstrapping.  Defining
hooks, defining options.

This work includes frontend template.  That's the smallest possible
frontend, that even doesn't emit any code, just writes out some stuff
(but it has all inits in place and ready for real thing).  Go through
the files and code in that template, and briefly describe hooks and
interesting things.  Leave the full catalogues to subsequent chapters.

About integration.  Mention slow round trip time: edit->compile->test
loop tends to be quite lengthy with GCC; you really want fast machine.
You can use IN\_GCC to special case your frontend to use GCC services
where available.

GCC uses garbage collector.  Describe GCC poisoning.  Probably go
through some GC codes, if apropriate.

\chapter{Targeting GCC}

This chapter should describe how to generate GCC intermediate language
called GENERIC.

Catalogue of constructions: how to translate symbol handing, nested
blocks, loops, funcalls, automatic and global variables, variable
sized arrays, multidimensional arrays, global, local (nested),
overloaded, internal, external, anonymous functions, visibility
(static or public), pass by value, reference and name, varargs,
modules, module ctors and dtors, jumps, cases, expressions,
typechecking, structures, objects, namespaces, name mangling and
C-compatible interfacing (extern "C"), (OpenMP?),
floating point, integer and string literals,
and others to GENERIC
(with the help of proper hooks).  Show examples taken from \Algol 60
code.

What are custom GENERIC codes, how to declare them, how to handle
them, what's gimplification, how to gimplify them.

Optimizing on tree level: how to emit IL that is compiled the fastest,
that emits the fastest code.  Does it even matter?

\chapter{Language Services}

How to add runtime for your language.

How to add debuginfos to binaries that your frontend produces.  How to
use gdb for your language.

\chapter{GCC Extensions}

Employing libcpp.  How to use preprocessor for your language.

Employing assembly.  How to add GCC-compatible inline assembly into
your language.

Employing attributes.  How does frontend handle attributes, how does
it define its own.

Employing GCC diagnostic messages.  Btw, you really want to do that,
otherwise your buggy programs will be passed and a binary generated,
or GCC crashed, depending on how is your error handling done.
Describe the `pedantic' variable.  Describe pedwarn, warning, error
and friends.  report\_diagnostic, diagnostic\_info and friends.
Report code excerpts with verbatim.  It seems that GCC uses it's own
printing functions, with their own formatting.  See e.g. comment
before pp\_base\_format.  Describe that.

What's dejagnu testsuite, how to write tests, how to integrate them
into GCC testsuite.  You need acurate error reporting to use the
dejagnu GCC framework.  In fortran, they are doing transformations of
error messages to format expected by the framework, describe that.

\chapter{Conclusions}

Conclusions: ``short, concise statements of the inferences that you
have made because of your work. It helps to organize these as short
numbered paragraphs, ordered from most to least important.''

Summary of Contributions: ``The Summary of Contributions will be much
sought and carefully read by the examiners.  Here you list the
contributions of new knowledge that your thesis makes. Of course, the
thesis itself must substantiate any claims made here. There is often
some overlap with the Conclusions, but that's okay. Concise numbered
paragraphs are again best. Organize from most to least important.''

Future Research: How feasible would be to have a frontend, that just
hands all the calls to dynamically loaded external parser?  This would
allow for out-of-tree builds, wouldn't it?

\chapter*{Appendix: Frontend-to-Middleend Interface}

Describe all data structures that frontend touches.
http://gcc.gnu.org/projects/documentation.html, project "Fully
document the interface of front ends to GCC"

\chapter*{Appendix: \Algol 60 Compiler}

Installation, supported GCCs, usual stuff.



\chapter{Notes}

Functions need a return statements.  Look how it's done for noreturn
functions.

COND\_EXPR breaks when other value than 0 or 1 is used as condition.


\end{document}
