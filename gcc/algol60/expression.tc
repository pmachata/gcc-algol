// ------------------------------------
//   ROOT EXPRESSION NODE
// ------------------------------------

%node expression %abstract %typedef = {
  cursor_t * cursor;
}

/// Dump the expression to string.  Returns 'buf', or allocated buffer
/// if 'buf' was NULL.  Contents of non-NULL 'buf' is overwritten.
%operation estring_t * expr_to_str (expression * self, estring_t * buf) = { NULL }

/// Get the type of the expression.
%operation type * expr_type (expression * self) = { type_unknown () }

/// Resolve symbols used in this expression.  By the time this gets
/// called, symtabs should be already filled.  Typechecking should be
/// also performed here.
%operation void expr_resolve_symbols (expression * self, container * block, logger_t * log);

/// Answer whether this expression is lvalue.
%operation int expr_is_lvalue (expression * self) = { 0 }

expr_is_lvalue (expression)
{
  // fallback: ordinary expressions aren't lvalues
  return 0;
}



// ------------------------------------
//   INTEGER NUMBER NODE
// ------------------------------------

%node expr_int expression = {
  int value;
}

expr_to_str (expr_int)
{
  if (buf == NULL)
    buf = new_estring ();
  estr_printf (buf, "%d", self->value);
  return buf;
}

expr_type (expr_int)
{
  return type_int ();
}

expr_resolve_symbols (expr_int)
{
  // nothing
}



// ------------------------------------
//   REAL NUMBER NODE
// ------------------------------------

%node expr_real expression = {
  estring_t * value;
}

expr_to_str (expr_real)
{
  if (buf == NULL)
    buf = new_estring ();
  estr_assign (buf, self->value);
  return buf;
}

expr_type (expr_real)
{
  return type_real ();
}

expr_resolve_symbols (expr_real)
{
  // nothing
}




// ------------------------------------
//   STRING LITERAL NODE
// ------------------------------------

%node expr_string expression = {
  estring_t * value;
}

expr_to_str (expr_string)
{
  if (buf == NULL)
    buf = new_estring ();
  estr_assign (buf, self->value);
  return buf;
}

expr_type (expr_string)
{
  return type_string ();
}

expr_resolve_symbols (expr_string)
{
  // nothing
}



// ------------------------------------
//   BOOLEAN LITERAL NODE
// ------------------------------------

%node expr_bool expression = {
  int value;
}

expr_to_str (expr_bool)
{
  if (buf == NULL)
    buf = new_estring ();
  estr_assign_cstr (buf, self->value ? "'true'" : "'false'");
  return buf;
}

expr_type (expr_bool)
{
  return type_bool ();
}

expr_resolve_symbols (expr_bool)
{
  // nothing
}



// ------------------------------------
//   IDENTIFIER NODE
// ------------------------------------

%node expr_idref expression = {
  label * lbl;
  %nocreate symbol * sym = { NULL };
}

expr_to_str (expr_idref)
{
  return symbol_to_str (self->sym, buf);
}

expr_type (expr_idref)
{
  return self->sym->type;
}

expr_resolve_symbols (expr_idref)
{
  type * match_type = t_proc_create (type_any (), new_slist ());
  symbol * found = container_find_name_rec (block, self->lbl, match_type);
  if (found == NULL)
    found = container_find_name_rec_add_undefined (block, self->lbl, type_any (),
						   log, self->cursor);
  self->sym = found;
}

expr_is_lvalue (expr_idref)
{
  return 1;
}



// ------------------------------------
//   IF-EXPRESSION NODE
// ------------------------------------

%node expr_if expression = {
  expression * cond;
  expression * exp_t;
  expression * exp_f;
  %nocreate type * result_type = { NULL };
}

expr_to_str (expr_if)
{
  buf = expr_to_str (self->cond, buf);
  estr_prepend_cstr (buf, "'if' ");
  estr_append_cstr (buf, " 'then' ");
  estring_t * s = expr_to_str (self->exp_t, NULL);
  estr_append (buf, s);
  estr_append_cstr (buf, " 'else' ");
  expr_to_str (self->exp_f, s);
  estr_append (buf, s);
  delete_estring (s);
  return buf;
}

expr_type (expr_if)
{
  return self->result_type;
}

expr_resolve_symbols (expr_if)
{
  expr_resolve_symbols (self->cond, block, log);
  expr_resolve_symbols (self->exp_t, block, log);
  expr_resolve_symbols (self->exp_f, block, log);

  type* ct = expr_type (self->cond);
  type* tt = expr_type (self->exp_t);
  type* ft = expr_type (self->exp_f);

  if (!types_same (ct, type_bool ()))
    {
      log_printfc (log, ll_error, self->cursor,
		   "`if' expression condition has to be boolean");
      self->cond = expr_primitive_for_type (type_bool ());
    }

  self->result_type = tt;
  if (!types_same (tt, ft)) // match is not enough
    {
      log_printfc (log, ll_error, self->cursor,
                   "both `if' branches have to have same types");
      self->exp_f = expr_primitive_for_type (tt);
    }
}

expr_is_lvalue (expr_if)
{
  // @TODO
  // Technically this is ok:
  //   if cond then a else b := 4;
  // but Algol doesn't allow this, plus with the most trivial scenario
  // of `gimme lvalue target' this doesn't work statically and
  // requires extra support.  So yes, do this as an extension if you
  // have tons of time, but for the time being...
  return 0;
}




// ------------------------------------
//   ORDINARY EXPRESSION NODES
// ------------------------------------

%node expr_bin expression %abstract = {
  expression * left;
  expression * right;
}

/// Answer the string that represents the operator
%operation char const* expr_bin_op_str (expr_bin * self) = { NULL }

/// Answer the type of the binary expression.  The methods for this
/// operation are in expr_types.tc.
%operation type* expr_bin_type ([expr_bin * self], [type * ltype], [type * rtype]) = { NULL }


expr_to_str (expr_bin)
{
  buf = expr_to_str (self->left, buf);
  estr_prepend_cstr (buf, "(");
  estr_push (buf, ' ');
  estr_append_cstr (buf, expr_bin_op_str (self));
  estr_push (buf, ' ');
  estring_t * s = expr_to_str (self->right, NULL);
  estr_append (buf, s);
  estr_push (buf, ')');
  delete_estring (s);
  return buf;
}

expr_type (expr_bin)
{
  return expr_bin_type (self, expr_type (self->left), expr_type (self->right));
}

expr_resolve_symbols (expr_bin)
{
  expr_resolve_symbols (self->left, block, log);
  expr_resolve_symbols (self->right, block, log);

  type* tt = expr_type (ast_as (expression, self));
  if (is_unknown (tt))
    {
      // @TODO: there should me some error recovery; this way our node
      // ends up being type_unknown, and avalanche of errors is
      // blurted on the user

      estring_t * es = expr_to_str (ast_as (expression, self), NULL);
      estring_t * tmp = type_to_str (expr_type (self->left), NULL);
      estr_prepend_cstr (es, "type mismatch in expression `");
      estr_append_cstr (es, "': ");
      estr_append (es, tmp);
      estr_push (es, ' ');
      estr_append_cstr (es, expr_bin_op_str (ast_as (expr_bin, self)));
      estr_push (es, ' ');
      type_to_str (expr_type (self->right), tmp);
      estr_append (es, tmp);

      log_printfc (log, ll_error, self->cursor, "%s", estr_cstr (es));

      delete_estring (es);
      delete_estring (tmp);
    }
}


%node expr_arith expr_bin %abstract = {
}

%node expr_aadd expr_arith = {}
expr_bin_op_str (expr_aadd) {return "+";}

%node expr_asub expr_arith = {}
expr_bin_op_str (expr_asub) {return "-";}

%node expr_amul expr_arith = {}
expr_bin_op_str (expr_amul) {return "*";}

%node expr_aidiv expr_arith = {}
expr_bin_op_str (expr_aidiv) {return "'div'";}

%node expr_ardiv expr_arith = {}
expr_bin_op_str (expr_ardiv) {return "/";}

%node expr_apow expr_arith = {}
expr_bin_op_str (expr_apow) {return "**";}


%node expr_rel expr_bin %abstract = {}


%node expr_req expr_rel = {}
expr_bin_op_str (expr_req) {return "=";}

%node expr_rneq expr_rel = {}
expr_bin_op_str (expr_rneq) {return "!=";}

%node expr_rlt expr_rel = {}
expr_bin_op_str (expr_rlt) {return "<";}

%node expr_rlte expr_rel = {}
expr_bin_op_str (expr_rlte) {return "<=";}

%node expr_rgt expr_rel = {}
expr_bin_op_str (expr_rgt) {return ">";}

%node expr_rgte expr_rel = {}
expr_bin_op_str (expr_rgte) {return ">=";}



%node expr_log expr_bin %abstract = {}
expr_type (expr_log) { return type_bool (); }


%node expr_limp expr_log = {}
expr_bin_op_str (expr_limp) {return "=>";}

%node expr_leq expr_log = {}
expr_bin_op_str (expr_leq) {return "==";}

%node expr_lor expr_log = {}
expr_bin_op_str (expr_lor) {return "||";}

%node expr_land expr_log = {}
expr_bin_op_str (expr_land) {return "&&";}


%node expr_un expression %abstract = {
  expression * operand;
}

/// Answer the string that represents the operator
%operation char const* expr_un_op_str (expr_un * self) = { NULL }

/// Answer the type of the unary expression.  The methods for this
/// operation are in expr_types.tc.
%operation type * expr_un_type ([expr_un * self], [type * operand_type]) = { NULL }

expr_to_str (expr_un)
{
  buf = expr_to_str (self->operand, buf);
  estr_prepend_cstr (buf, expr_un_op_str (self));
  estr_prepend_cstr (buf, "(");
  estr_push (buf, ')');
  return buf;
}

expr_type (expr_un)
{
  return expr_un_type (self, expr_type (self->operand));
}

expr_resolve_symbols (expr_un)
{
  expr_resolve_symbols (self->operand, block, log);
}


%node expr_uminus expr_un = {}
expr_un_op_str (expr_uminus) {return "-";}

%node expr_not expr_un = {}
expr_un_op_str (expr_not) {return "!";}



// ------------------------------------
//   FUNCALL NODE
// ------------------------------------

%{
static void
private_render_exprs_slist (slist_t * slist, estring_t * buf,
                            char const * open, char const * close)
{
  if (!slist_empty (slist))
    {
      estr_append_cstr (buf, open);
      slist_it_t * it = slist_iter (slist);
      estring_t * tmp = new_estring ();
      while (1)
	{
	  expression * arg = slist_it_get (it);
	  tmp = expr_to_str (arg, tmp);
	  estr_append (buf, tmp);
	  slist_it_next (it);
	  if (!slist_it_has (it))
	    break;
	  estr_append_cstr (buf, ", ");
	}
      delete_slist_it (it);
      delete_estring (tmp);
      estr_append_cstr (buf, close);
    }
}

%}

%node expr_call expression = {
  label * lbl;
  slist_t * arguments;
  %nocreate symbol * sym = { NULL };
}

expr_to_str (expr_call)
{
  buf = label_to_str (self->lbl, buf);
  private_render_exprs_slist (self->arguments, buf, "(", ")");
  return buf;
}

expr_type (expr_call)
{
  return ast_as (t_proc, self->sym->type)->ret_type;
}

expr_resolve_symbols (expr_call)
{
  slist_t * argtypes = new_slist ();
  slist_it_t * it = slist_iter (self->arguments);
  for (; slist_it_has (it); slist_it_next (it))
    {
      expression * arg = slist_it_get (it);
      expr_resolve_symbols (arg, block, log);
      type * argtype = expr_type (arg);
      slist_pushback (argtypes, argtype);
    }
  delete_slist_it (it);

  type * match_type = t_proc_create (type_any (), argtypes);
  self->sym = container_find_name_rec_add_undefined (block, self->lbl, match_type,
						     log, self->cursor);
  delete_slist (argtypes);
}


// ------------------------------------
//   SUBSCRIPT EXPR NODE
// ------------------------------------

%node expr_subscript expression = {
  label * lbl;
  slist_t * indices;
  %nocreate symbol * sym = { NULL };
}

expr_to_str (expr_subscript)
{
  buf = label_to_str (self->lbl, buf);
  private_render_exprs_slist (self->indices, buf, "[", "]");
  return buf;
}

expr_type (expr_subscript)
{
  // Assume that the user provided just the right number of indices.
  // We are actually checking for that in expr_resolve_symbols.
  return type_get_root (self->sym->type);
}

expr_resolve_symbols (expr_subscript)
{
  slist_it_t * it = slist_iter (self->indices);
  for (; slist_it_has (it); slist_it_next (it))
    {
      expression * e = slist_it_get (it);
      expr_resolve_symbols (e, block, log);
    }
  delete_slist_it (it);

  self->sym = container_find_name_rec_add_undefined (block, self->lbl,
						     type_array_any (),
						     log, self->cursor);

  if (types_match (self->sym->type, type_array_any ()))
    // this may not be true if the symbol was added artificially by
    // container_find_name_rec_add_undefined.  In such a case an error
    // message was emitted already, and we don't have to care.
    {
      int num_indices = slist_length (self->indices);
      int num_dimensions = 0;
      type * t = self->sym->type;
      if (ast_isa (t, t_own))
	t = ast_as (t_own, t)->host;
      for (; ast_isa (t, t_array); t = ast_as (t_array, t)->host)
	++num_dimensions;

      if (num_dimensions != num_indices)
	{
	  log_printfc (log, ll_error, self->cursor,
		       "%d indices provided for %dD array",
		       num_indices, num_dimensions);
	}
    }
}

expr_is_lvalue (expr_subscript)
{
  return 1;
}

/*
 * Local Variables:
 * mode: c
 * c-syntactic-indentation: nil
 * End:
 */
