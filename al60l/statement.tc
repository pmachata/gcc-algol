// ------------------------------------
//   ROOT STATEMENT NODE
// ------------------------------------

/// Root AST node for statements.
%node statement %abstract %typedef = {
  %nocreate container * parent = { NULL };
}

/// Dump (i.e. rewrite from AST back to code) the tree to given file
/// `ofile' with basic indentation of `level' spaces.
%operation void statement_dump (statement * self, FILE * ofile, int level)

/// Resolve symbols used in this statement.  By the time this gets
/// called, symtabs should be already filled.  Typechecking should be
/// also performed here.
%operation void stmt_resolve_symbols (statement * self, logger_t * log);



// ------------------------------------
//   DUMMY STATEMENT NODE
// ------------------------------------

%node stmt_dummy statement = {
}

statement_dump (stmt_dummy)
{
  fprintf (ofile, "%s;\n", padding (level));
}

stmt_resolve_symbols (stmt_dummy)
{
  // nothing
}


// ------------------------------------
//   ASSIGNMENT STATEMENT NODE
// ------------------------------------

%node stmt_assign statement = {
  %nocreate expression * rhs = { NULL };
  %nocreate slist_t * lhss = { new_slist () };
}

%operation void stmt_assign_set_rhs (stmt_assign * self, expression * expr);
%operation void stmt_assign_add_lhs (stmt_assign * self, expression * expr);

statement_dump (stmt_assign)
{
  slist_it_t * it = slist_iter (self->lhss);
  estring_t * buf = new_estring ();
  fprintf (ofile, "%s", padding (level));
  for (; slist_it_has (it); slist_it_next (it))
    {
      expression * expr = slist_it_get (it);
      fprintf (ofile, "%s := ", estr_cstr (expr_to_str (expr, buf)));
    }
  fprintf (ofile, "%s;\n", estr_cstr (expr_to_str (self->rhs, buf)));
  delete_estring (buf);
  delete_slist_it (it);
}

stmt_assign_set_rhs (stmt_assign)
{
  self->rhs = expr;
}

stmt_assign_add_lhs (stmt_assign)
{
  slist_pushback (self->lhss, expr);
}

stmt_resolve_symbols (stmt_assign)
{
  expr_resolve_symbols (self->rhs, self->parent, log);
  slist_it_t * it = slist_iter (self->lhss);
  for (; slist_it_has (it); slist_it_next (it))
    expr_resolve_symbols (slist_it_get (it), self->parent, log);
  delete_slist_it (it);

  type * tt = expr_type (self->rhs);
  it = slist_iter (self->lhss);
  for (; slist_it_has (it); slist_it_next (it))
    {
      expression * lhs = slist_it_get (it);
      type * t1 = expr_type (lhs);
      if (!types_same (tt, t1))
	{
	  estring_t * s1 = expr_to_str (lhs, NULL);
	  estring_t * s2 = expr_to_str (self->rhs, NULL);
	  estring_t * s3 = type_to_str (t1, NULL);
	  estring_t * s4 = type_to_str (tt, NULL);
	  log_printf (log, ll_error,
		      "type mismatch in assignment %s := %s (%s doesn't match %s)",
		      estr_cstr (s1), estr_cstr (s2), estr_cstr (s3), estr_cstr (s4));
	  delete_estring (s1);
	  delete_estring (s2);
	  delete_estring (s3);
	  delete_estring (s4);
	}
      if (!expr_is_lvalue (lhs))
	{
	  estring_t * s1 = expr_to_str (lhs, NULL);
	  log_printf (log, ll_error,
		      "%s has to be an lvalue",
		      estr_cstr (s1));
	  delete_estring (s1);
	}
    }
  delete_slist_it (it);
}


// ------------------------------------
//   FUNCALL STATEMENT NODE
// ------------------------------------

%node stmt_call statement = {
  expression * call;
}

statement_dump (stmt_call)
{
  estring_t * buf = expr_to_str (self->call, NULL);
  fprintf (ofile, "%s%s;\n", padding (level), estr_cstr (buf));
  delete_estring (buf);
}

stmt_resolve_symbols (stmt_call)
{
  expr_resolve_symbols (self->call, self->parent, log);
}


// ------------------------------------
//   CONTAINER ROOT NODE
// ------------------------------------

%node container statement %abstract = {
  %nocreate slist_t * commands = { new_slist () };
  %nocreate slist_t * symtab = { new_slist () };
}

/// Add new command into container.
%operation void container_add_stmt (container * self, statement * stmt)

%decls %{
typedef enum enum_symtab_entry_kind_t
{
  sek_internal,
  sek_ordinary
} symtab_entry_kind_t;
%}

/// Add given symbol to the container and return 0.  It there already
/// is other symbol with the same name, do nothing and return -1.
/// `internal' is 1 for internal symbols (which may be overloaded) and
/// 0 for ordinary symbols (which may not).  This means that with
/// internal==1, this function will always answer 0.
%operation int container_add_symbol (container * self, symbol * sym, symtab_entry_kind_t internal) = { 0 }

/// Lookup given symbol in the container.  Answer first symbol that
/// matches restriction `atype', or first symbol with NULL type (in
/// which case type can't be checked).  Return NULL if not found.
%operation symbol * container_find_name ([container * self], label * lbl, type * atype) = { NULL }

/// Lookup given symbol in the container, and if it fails, recursively
/// in all parental containers.  Answer first symbol that matches
/// restriction `atype', or first symbol with NULL type (in which case
/// type can't be checked).  Return NULL if not found.
%operation symbol * container_find_name_rec ([container * self], label * lbl, type * atype) = { NULL }

stmt_resolve_symbols (container)
{
  slist_it_t * it = slist_iter (self->commands);
  for (; slist_it_has (it); slist_it_next (it))
    stmt_resolve_symbols (slist_it_get (it), log);
  delete_slist_it (it);

  estring_t * tmp = NULL;
  it = slist_iter (self->symtab);
  for (; slist_it_has (it); slist_it_next (it))
    {
      symbol * sym = slist_it_get (it);
      if (sym->lbl->arr_bd_list != NULL
	  && !slist_empty (sym->lbl->arr_bd_list))
	{
	  slist_it_t * jt = slist_iter (sym->lbl->arr_bd_list);
	  for (; slist_it_has (jt); slist_it_next (jt))
	    {
	      boundspair * bp = slist_it_get (jt);
	      expression * hi = bp->hibound;
	      expression * lo = bp->lobound;
	      // symbols in bounds are resolved with use of parental
	      // symtab; this is illegal:
	      //  'begin' 'integer' y; 'integer' 'array' z[1:y]; 'end';
	      expr_resolve_symbols (lo, self->parent, log);
	      expr_resolve_symbols (hi, self->parent, log);
	      type * lot = expr_type (lo);
	      type * hit = expr_type (hi);

	      if (!types_match (lot, type_int ()))
		{
		  log_printf (log, ll_error,
			      "invalid type `%s' in lower boundary",
			      estr_cstr (tmp = type_to_str (lot, tmp)));
		  bp->lobound = expr_primitive_for_type (type_int ());
		}

	      if (!types_match (hit, type_int ()))
		{
		  log_printf (log, ll_error,
			      "invalid type `%s' in upper boundary",
			      estr_cstr (tmp = type_to_str (hit, tmp)));
		  bp->hibound = expr_primitive_for_type (type_int ());
		}
	    }
	  delete_slist_it (jt);
	}
    }
  delete_slist_it (it);
  delete_estring (tmp);
}

%decls %end %{
/// See if given symbol with requested matching type, is already
/// defined somewhere in the scope.  If it's not, create new
/// definition in most enclosing scope.  Answer either found, or newly
/// created symbol.
symbol * container_find_name_rec_add_undefined (container * self, label * lbl, type * atype, logger_t * log);
%}


%{
symbol *
container_find_name_rec_add_undefined (container * self, label * lbl, type * atype, logger_t * log)
{
  estring_t * tmp = NULL;
  symbol * found = container_find_name_rec (self, lbl, atype);
  if (found == NULL)
    {
      if (types_same (atype, type_any ()))
	log_printf (log, ll_error, "(1) unknown symbol named `%s'",
		    estr_cstr (tmp = label_to_str (lbl, tmp)));
      else
	{
	  // second chance: look up any symbol of that name
	  found = container_find_name_rec (self, lbl, type_any ());
	  if (found == NULL)
	    {
	      log_printf (log, ll_error, "(2) unknown symbol named `%s'",
			  estr_cstr (tmp = label_to_str (lbl, tmp)));
	    }
	  else
	    {
	      tmp = label_to_str (lbl, tmp);
	      estring_t * t1s = type_to_str (atype, NULL);
	      estring_t * t2s = type_to_str (found->type, NULL);
	      estring_t * fmt =
		new_estring_fmt ("type mismatch for symbol `%s': "
				 "requested type `%s', found type `%s'",
				 estr_cstr (tmp), estr_cstr (t1s), estr_cstr (t2s));
	      log_printf (log, ll_error, "%s", estr_cstr (fmt));
	      delete_estring (fmt);
	      delete_estring (t2s);
	      delete_estring (t1s);
	    }
	}
      int was_there = container_add_symbol (self, symbol_create (lbl), sek_ordinary);
      assert (!was_there);
      found = container_find_name (self, lbl, atype);
      // mark a type at new symbol, either fallback type_int, or
      // atype, if it has suitable type
      symbol_set_type (found, is_metatype (atype) ? type_int () : atype);
    }
  assert (found != NULL);
  delete_estring (tmp);

  return found;
}

void
private_dump_container (container * self, FILE * ofile, int level)
{
  estring_t * buf = new_estring ();

  // dump all variables but labels and hidden symbols
  slist_it_t * it = slist_iter (self->symtab);
  for (; slist_it_has (it); slist_it_next (it))
    {
      symbol * sym = slist_it_get (it);
      if (ast_isa (sym->type, t_label)
	  || sym->hidden)
	continue;

      type_to_str_canon (sym->type, buf);
      fprintf (ofile, "%s%s", padding (level), estr_cstr (buf));
      label_to_str (sym->lbl, buf);
      fprintf (ofile, " %s", estr_cstr (buf));
      if (sym->lbl->arr_bd_list != NULL
	  && !slist_empty (sym->lbl->arr_bd_list))
	{
	  fprintf (ofile, "[");
	  slist_it_t * jt = slist_iter (sym->lbl->arr_bd_list);
	  while (1)
	    {
	      boundspair * bp = slist_it_get (jt);
	      expr_to_str (bp->lobound, buf);
	      fprintf (ofile, "%s:", estr_cstr (buf));
	      expr_to_str (bp->hibound, buf);
	      fprintf (ofile, "%s", estr_cstr (buf));
	      slist_it_next (jt);
	      if (slist_it_has (jt))
		fprintf (ofile, ",");
	      else
		break;
	    }
	  fprintf (ofile, "]");
	}
      fprintf (ofile, ";\n");
    }
  delete_slist_it (it);

  // dump all statemenets
  it = slist_iter (self->commands);
  for (;slist_it_has (it);)
    {
      statement * stmt = slist_it_get (it);

      // look for any labels pointing to this command
      slist_it_t * lt = slist_iter (self->symtab);
      for (; slist_it_has (lt); slist_it_next (lt))
	{
	  symbol * sym = slist_it_get (lt);
	  if (ast_isa (sym->type, t_label)
	      && sym->stmt == stmt)
	    {
	      label_to_str (sym->lbl, buf);
	      fprintf (ofile, "%s%s:\n", padding (level), estr_cstr (buf));
	    }
	}
      delete_slist_it (lt);

      slist_it_next (it);

      // dump the statement itself.  Don't dump it, if there are no
      // more statements in container (i.e. `stmt' is last statement)
      // and `stmt' is dummy statement.
      if (slist_it_has (it) || !ast_isa (stmt, stmt_dummy))
	statement_dump (stmt, ofile, level);
      else
	break;
    }
  delete_slist_it (it);

  delete_estring (buf);
}
%}

statement_dump (container)
{
  // container doesn't render 'begin'-'end' enclosing, thus not level+1
  private_dump_container (self, ofile, level);
}

container_add_stmt (container)
{
  slist_pushback (self->commands, stmt);
  stmt->parent = self;
}

container_add_symbol (container)
{
  if (internal == sek_ordinary
      && container_find_name (self, sym->lbl, type_any ()) != NULL)
    return -1;

  slist_pushback (self->symtab, sym);
  return 0;
}

container_find_name (container)
{
  slist_it_t * it;
  for (it = slist_iter (self->symtab); slist_it_has (it); slist_it_next (it))
    {
      symbol * sym = slist_it_get (it);
      if (label_eq (sym->lbl, lbl)
	  && (sym->type == NULL || types_match (sym->type, atype)))
	return sym;
    }
  return NULL;
}

container_find_name_rec (container)
{
  symbol * sym = container_find_name (self, lbl, atype);
  if (sym == NULL && self->parent != NULL)
    return container_find_name_rec (self->parent, lbl, atype);
  else
    return sym;
}

// ------------------------------------
//   BLOCK STATEMENT NODE
// ------------------------------------

%node stmt_block container = {
}

statement_dump (stmt_block)
{
  fprintf (ofile, "%s'begin'\n", padding (level));
  private_dump_container (ast_as (container, self), ofile, level+1);
  fprintf (ofile, "%s'end';\n", padding (level));
}


// ------------------------------------
//   TOPLEV CONTAINER NODE
// ------------------------------------

%node stmt_toplev container = {
}

statement_dump (stmt_toplev)
{
  private_dump_container (ast_as (container, self), ofile, level);
}

%decls %end %{
/// Populate given container with algol internal functions.
void stmt_toplev_define_internals (stmt_toplev * self);
%}

%{
void
stmt_toplev_define_internals (stmt_toplev * self)
{
  struct interfun {
    char const* n;
    type * t;
  } builtins [] =
  {
    {"exit", type_proc_void_int ()},
    {"abs",  type_proc_real_real ()},
    {"abs",  type_proc_int_int ()},
    {"sign", type_proc_real_int ()},
    {"sqrt", type_proc_real_real ()},
    {"sin",  type_proc_real_real ()},
    {"cos",  type_proc_real_real ()},
    {"arctan", type_proc_real_real ()},
    {"ln",   type_proc_real_real ()},
    {"exp",  type_proc_real_real ()},
    {"entier", type_proc_int_real ()},
    {NULL,   NULL}
  };

  for (struct interfun * ptr = builtins;
       ptr->n != NULL; ptr++)
    {
      symbol * s = symbol_create (label_id_create (new_estring_from (ptr->n)));
      symbol_set_type (s, ptr->t);
      symbol_set_hidden (s, 1);
      int fail = container_add_symbol (ast_as (container, self), s, sek_internal);
      assert (fail == 0);
    }
}
%}


/*
 * Local Variables:
 * mode: c
 * c-syntactic-indentation: nil
 * End:
 */
