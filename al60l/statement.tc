// ------------------------------------
//   ROOT STATEMENT NODE
// ------------------------------------

/// Root AST node for statements.
%node statement %abstract %typedef = {
  %nocreate container * parent = { NULL };
}

/// Dump (i.e. rewrite from AST back to code) the tree to given file
/// `ofile' with basic indentation of `level' spaces.
%operation void statement_dump (statement * self, FILE * ofile, int level)



// ------------------------------------
//   DUMMY STATEMENT NODE
// ------------------------------------

%node stmt_dummy statement = {
}

statement_dump (stmt_dummy)
{
  fprintf (ofile, "%s;\n", padding (level));
}


// ------------------------------------
//   CONTAINER ROOT NODE
// ------------------------------------

%node container statement %abstract = {
  %nocreate slist_t * commands = { new_slist () };
  %nocreate slist_t * symtab = { new_slist () };
}

/// Add new command into container.
%operation void container_add_stmt (container * self, statement * stmt)

/// Add given symbol to the container and return 0.  It there already
/// is other symbol with the same name, do nothing and return -1.
%operation int container_add_symbol (container * self, symbol * sym) = { 0 }

/// Lookup given symbol in the container.
%operation symbol * container_find_name ([container * self], label * lbl) = { NULL }

/// Lookup given symbol in the container, and if it fails,
/// recursively in all parental containers.
%operation symbol * container_find_name_rec ([container * self], label * lbl) = { NULL }


%{
void
private_dump_container (container * self, FILE * ofile, int level)
{
  estring_t * buf = new_estring ();

  // dump all variables but labels
  slist_it_t * it = slist_iter (self->symtab);
  for (; slist_it_has (it); slist_it_next (it))
    {
      symbol * sym = slist_it_get (it);
      if (sym->type == type_label ())
	continue;

      type_to_str_canon (sym->type, buf);
      fprintf (ofile, "%s%s", padding (level), estr_cstr (buf));
      label_to_str (sym->lbl, buf);
      fprintf (ofile, " %s", estr_cstr (buf));
      if (sym->arr_bd_list != NULL
	  && !slist_empty (sym->arr_bd_list))
	{
	  fprintf (ofile, "[");
	  slist_it_t * jt = slist_iter (sym->arr_bd_list);
	  while (1)
	    {
	      boundspair * bp = slist_it_get (jt);
	      expr_to_str (bp->lobound, buf);
	      fprintf (ofile, "%s:", estr_cstr (buf));
	      expr_to_str (bp->hibound, buf);
	      fprintf (ofile, "%s", estr_cstr (buf));
	      slist_it_next (jt);
	      if (slist_it_has (jt))
		fprintf (ofile, ",");
	      else
		break;
	    }
	  fprintf (ofile, "]");
	}
      fprintf (ofile, ";\n");
    }
  delete_slist_it (it);

  // dump all statemenets
  it = slist_iter (self->commands);
  for (;slist_it_has (it);)
    {
      statement * stmt = slist_it_get (it);

      // look for any labels pointing to this command
      slist_it_t * lt = slist_iter (self->symtab);
      for (; slist_it_has (lt); slist_it_next (lt))
	{
	  symbol * sym = slist_it_get (lt);
	  if (sym->type == type_label ()
	      && sym->stmt == stmt)
	    {
	      label_to_str (sym->lbl, buf);
	      fprintf (ofile, "%s%s:\n", padding (level), estr_cstr (buf));
	    }
	}
      delete_slist_it (lt);

      slist_it_next (it);

      // dump the statement itself.  Don't dump it, if there are no
      // more statements in container (i.e. `stmt' is last statement)
      // and `stmt' is dummy statement.
      if (slist_it_has (it) || !ast_isa (stmt, stmt_dummy))
	statement_dump (stmt, ofile, level);
      else
	break;
    }
  delete_slist_it (it);

  delete_estring (buf);
}
%}

statement_dump (container)
{
  // container doesn't render 'begin'-'end' enclosing, thus not level+1
  private_dump_container (self, ofile, level);
}

container_add_stmt (container)
{
  slist_pushback (self->commands, stmt);
  stmt->parent = self;
}

container_add_symbol (container)
{
  if (container_find_name (self, sym->lbl) != NULL)
    return -1;

  slist_pushback (self->symtab, sym);
  return 0;
}

container_find_name (container)
{
  slist_it_t * it;
  for (it = slist_iter (self->symtab); slist_it_has (it); slist_it_next (it))
    {
      symbol * sym = slist_it_get (it);
      if (label_eq (sym->lbl, lbl))
	return sym;
    }
  return NULL;
}

container_find_name_rec (container)
{
  symbol * sym = container_find_name (self, lbl);
  if (sym == NULL && self->parent != NULL)
    return container_find_name_rec (self->parent, lbl);
  else
    return NULL;
}

// ------------------------------------
//   BLOCK STATEMENT NODE
// ------------------------------------

%node stmt_block container = {
}

statement_dump (stmt_block)
{
  fprintf (ofile, "%s'begin'\n", padding (level));
  private_dump_container (ast_as (container, self), ofile, level+1);
  fprintf (ofile, "%s'end';\n", padding (level));
}


// ------------------------------------
//   TOPLEV CONTAINER NODE
// ------------------------------------

%node stmt_toplev container = {
}

statement_dump (stmt_toplev)
{
  private_dump_container (ast_as (container, self), ofile, level);
}


/*
 * Local Variables:
 * mode: c
 * c-syntactic-indentation: nil
 * End:
 */
