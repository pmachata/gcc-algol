// ------------------------------------
//   ROOT STATEMENT NODE
// ------------------------------------

/// Root AST node for statements.
%node statement %abstract %typedef = {
  %nocreate container * parent = { NULL };
}

/// Dump (i.e. rewrite from AST back to code) the tree to given file
/// `ofile' with basic indentation of `level' spaces.
%operation void statement_dump (statement * self, FILE * ofile, int level)

/// Resolve symbols used in this statement.  By the time this gets
/// called, symtabs should be already filled.  Typechecking should be
/// also performed here.
%operation void stmt_resolve_symbols (statement * self, logger_t * log);



// ------------------------------------
//   DUMMY STATEMENT NODE
// ------------------------------------

%node stmt_dummy statement = {
}

statement_dump (stmt_dummy)
{
  fprintf (ofile, "%s;\n", padding (level));
}

stmt_resolve_symbols (stmt_dummy)
{
  // nothing
}


// ------------------------------------
//   ASSIGNMENT STATEMENT NODE
// ------------------------------------

%node stmt_assign statement = {
  %nocreate expression * rhs = { NULL };
  %nocreate slist_t * lhss = { new_slist () };
}

%operation void stmt_assign_set_rhs (stmt_assign * self, expression * expr);
%operation void stmt_assign_add_lhs (stmt_assign * self, expression * expr);

statement_dump (stmt_assign)
{
  slist_it_t * it = slist_iter (self->lhss);
  estring_t * buf = new_estring ();
  fprintf (ofile, "%s", padding (level));
  for (; slist_it_has (it); slist_it_next (it))
    {
      expression * expr = slist_it_get (it);
      fprintf (ofile, "%s := ", estr_cstr (expr_to_str (expr, buf)));
    }
  fprintf (ofile, "%s;\n", estr_cstr (expr_to_str (self->rhs, buf)));
  delete_estring (buf);
  delete_slist_it (it);
}

stmt_assign_set_rhs (stmt_assign)
{
  self->rhs = expr;
}

stmt_assign_add_lhs (stmt_assign)
{
  slist_pushback (self->lhss, expr);
}

stmt_resolve_symbols (stmt_assign)
{
  expr_resolve_symbols (self->rhs, self->parent, log);
  slist_it_t * it = slist_iter (self->lhss);
  for (; slist_it_has (it); slist_it_next (it))
    expr_resolve_symbols (slist_it_get (it), self->parent, log);
  delete_slist_it (it);
  // @TODO: also check for lvalues and typecheck
}


// ------------------------------------
//   FUNCALL STATEMENT NODE
// ------------------------------------

%node stmt_call statement = {
  expression * call;
}

statement_dump (stmt_call)
{
  estring_t * buf = expr_to_str (self->call, NULL);
  fprintf (ofile, "%s%s;\n", padding (level), estr_cstr (buf));
  delete_estring (buf);
}

stmt_resolve_symbols (stmt_call)
{
  expr_resolve_symbols (self->call, self->parent, log);
}


// ------------------------------------
//   CONTAINER ROOT NODE
// ------------------------------------

%node container statement %abstract = {
  %nocreate slist_t * commands = { new_slist () };
  %nocreate slist_t * symtab = { new_slist () };
}

/// Add new command into container.
%operation void container_add_stmt (container * self, statement * stmt)

/// Add given symbol to the container and return 0.  It there already
/// is other symbol with the same name, do nothing and return -1.
%operation int container_add_symbol (container * self, symbol * sym) = { 0 }

/// Lookup given symbol in the container.  Return NULL if not found.
%operation symbol * container_find_name ([container * self], label * lbl) = { NULL }

/// Lookup given symbol in the container, and if it fails, recursively
/// in all parental containers.  Return NULL if not found.
%operation symbol * container_find_name_rec ([container * self], label * lbl) = { NULL }

stmt_resolve_symbols (container)
{
  slist_it_t * it = slist_iter (self->commands);
  for (; slist_it_has (it); slist_it_next (it))
    stmt_resolve_symbols (slist_it_get (it), log);
  delete_slist_it (it);
}

%decls %end %{
/// See if given symbol is already defined somewhere in the scope.  If
/// it's not, create new definition in most enclosing scope.  Answer
/// either found, or newly created symbol.
symbol * container_find_name_rec_add_undefined (container * self, symbol * sym, logger_t * log);
%}


%{
symbol *
container_find_name_rec_add_undefined (container * self, symbol * sym, logger_t * log)
{
  estring_t * tmp = NULL;
  symbol * found = container_find_name_rec (self, sym->lbl);
  if (found == NULL)
    {
      log_printf (log, ll_error, "unknown symbol named `%s'",
		  estr_cstr (tmp = label_to_str (sym->lbl, tmp)));
      int was_there = container_add_symbol (self, sym);
      assert (!was_there);
      found = container_find_name (self, sym->lbl);
    }
  assert (found != NULL);
  delete_estring (tmp);

  return found;
}

void
private_dump_container (container * self, FILE * ofile, int level)
{
  estring_t * buf = new_estring ();

  // dump all variables but labels and hidden symbols
  slist_it_t * it = slist_iter (self->symtab);
  for (; slist_it_has (it); slist_it_next (it))
    {
      symbol * sym = slist_it_get (it);
      if (ast_isa (sym->type, t_label)
	  || sym->hidden)
	continue;

      type_to_str_canon (sym->type, buf);
      fprintf (ofile, "%s%s", padding (level), estr_cstr (buf));
      label_to_str (sym->lbl, buf);
      fprintf (ofile, " %s", estr_cstr (buf));
      if (sym->arr_bd_list != NULL
	  && !slist_empty (sym->arr_bd_list))
	{
	  fprintf (ofile, "[");
	  slist_it_t * jt = slist_iter (sym->arr_bd_list);
	  while (1)
	    {
	      boundspair * bp = slist_it_get (jt);
	      expr_to_str (bp->lobound, buf);
	      fprintf (ofile, "%s:", estr_cstr (buf));
	      expr_to_str (bp->hibound, buf);
	      fprintf (ofile, "%s", estr_cstr (buf));
	      slist_it_next (jt);
	      if (slist_it_has (jt))
		fprintf (ofile, ",");
	      else
		break;
	    }
	  fprintf (ofile, "]");
	}
      fprintf (ofile, ";\n");
    }
  delete_slist_it (it);

  // dump all statemenets
  it = slist_iter (self->commands);
  for (;slist_it_has (it);)
    {
      statement * stmt = slist_it_get (it);

      // look for any labels pointing to this command
      slist_it_t * lt = slist_iter (self->symtab);
      for (; slist_it_has (lt); slist_it_next (lt))
	{
	  symbol * sym = slist_it_get (lt);
	  if (ast_isa (sym->type, t_label)
	      && sym->stmt == stmt)
	    {
	      label_to_str (sym->lbl, buf);
	      fprintf (ofile, "%s%s:\n", padding (level), estr_cstr (buf));
	    }
	}
      delete_slist_it (lt);

      slist_it_next (it);

      // dump the statement itself.  Don't dump it, if there are no
      // more statements in container (i.e. `stmt' is last statement)
      // and `stmt' is dummy statement.
      if (slist_it_has (it) || !ast_isa (stmt, stmt_dummy))
	statement_dump (stmt, ofile, level);
      else
	break;
    }
  delete_slist_it (it);

  delete_estring (buf);
}
%}

statement_dump (container)
{
  // container doesn't render 'begin'-'end' enclosing, thus not level+1
  private_dump_container (self, ofile, level);
}

container_add_stmt (container)
{
  slist_pushback (self->commands, stmt);
  stmt->parent = self;
}

container_add_symbol (container)
{
  if (container_find_name (self, sym->lbl) != NULL)
    return -1;

  slist_pushback (self->symtab, sym);
  return 0;
}

container_find_name (container)
{
  slist_it_t * it;
  for (it = slist_iter (self->symtab); slist_it_has (it); slist_it_next (it))
    {
      symbol * sym = slist_it_get (it);
      if (label_eq (sym->lbl, lbl))
	return sym;
    }
  return NULL;
}

container_find_name_rec (container)
{
  symbol * sym = container_find_name (self, lbl);
  if (sym == NULL && self->parent != NULL)
    return container_find_name_rec (self->parent, lbl);
  else
    return sym;
}

// ------------------------------------
//   BLOCK STATEMENT NODE
// ------------------------------------

%node stmt_block container = {
}

statement_dump (stmt_block)
{
  fprintf (ofile, "%s'begin'\n", padding (level));
  private_dump_container (ast_as (container, self), ofile, level+1);
  fprintf (ofile, "%s'end';\n", padding (level));
}


// ------------------------------------
//   TOPLEV CONTAINER NODE
// ------------------------------------

%node stmt_toplev container = {
}

statement_dump (stmt_toplev)
{
  private_dump_container (ast_as (container, self), ofile, level);
}

%decls %end %{
/// Populate given container with algol internal functions.
void stmt_toplev_define_internals (stmt_toplev * self);
%}

%{
void
stmt_toplev_define_internals (stmt_toplev * self)
{
  symbol * s = symbol_create (label_id_create (new_estring_from ("exit")));
  symbol_set_type (s, t_proc_create (type_void (), new_slist_from (1, type_int ())));
  symbol_set_hidden (s, 1);
  container_add_symbol (ast_as (container, self), s);
}
%}


/*
 * Local Variables:
 * mode: c
 * c-syntactic-indentation: nil
 * End:
 */
