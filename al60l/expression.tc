// ------------------------------------
//   ROOT EXPRESSION NODE
// ------------------------------------

%node expression %abstract %typedef = {
}

/// Dump the expression to string.  Returns 'buf', or allocated buffer
/// if 'buf' was NULL.  Contents of non-NULL 'buf' is overwritten.
%operation estring_t * expr_to_str (expression * self, estring_t * buf) = { NULL }

/// Get the type of the expression.
%operation type * expr_type (expression * self) = { type_unknown () }

/// Resolve symbols used in this expression.  By the time this gets
/// called, symtabs should be already filled.  Typechecking should be
/// also performed here.
%operation void expr_resolve_symbols (expression * self, container * block, logger_t * log);



// ------------------------------------
//   INTEGER NUMBER NODE
// ------------------------------------

%node expr_int expression = {
  int value;
}

expr_to_str (expr_int)
{
  if (buf == NULL)
    buf = new_estring ();
  estr_printf (buf, "%d", self->value);
  return buf;
}

expr_type (expr_int)
{
  return type_int ();
}

expr_resolve_symbols (expr_int)
{
  // nothing
}



// ------------------------------------
//   REAL NUMBER NODE
// ------------------------------------

%node expr_real expression = {
  double value;
}

expr_to_str (expr_real)
{
  if (buf == NULL)
    buf = new_estring ();
  estr_printf (buf, "%f", self->value);
  return buf;
}

expr_type (expr_real)
{
  return type_real ();
}

expr_resolve_symbols (expr_real)
{
  // nothing
}




// ------------------------------------
//   STRING LITERAL NODE
// ------------------------------------

%node expr_string expression = {
  estring_t * value;
}

expr_to_str (expr_string)
{
  if (buf == NULL)
    buf = new_estring ();
  estr_assign (buf, self->value);
  return buf;
}

expr_type (expr_string)
{
  return type_string ();
}

expr_resolve_symbols (expr_string)
{
  // nothing
}



// ------------------------------------
//   IDENTIFIER NODE
// ------------------------------------

%node expr_idref expression = {
  symbol * sym;
}

expr_to_str (expr_idref)
{
  return symbol_to_str (self->sym, buf);
}

expr_type (expr_idref)
{
  return self->sym->type;
}

expr_resolve_symbols (expr_idref)
{
  container_find_name_rec_add_undefined (block, self->sym, log);
}



// ------------------------------------
//   IF-EXPRESSION NODE
// ------------------------------------

%node expr_if expression = {
  expression * cond;
  expression * exp_t;
  expression * exp_f;
}

expr_to_str (expr_if)
{
  buf = expr_to_str (self->cond, buf);
  estr_prepend_cstr (buf, "'if' ");
  estr_append_cstr (buf, " 'then' ");
  estring_t * s = expr_to_str (self->exp_t, NULL);
  estr_append (buf, s);
  estr_append_cstr (buf, " 'else' ");
  expr_to_str (self->exp_f, s);
  estr_append (buf, s);
  delete_estring (s);
  return buf;
}

expr_type (expr_if)
{
  type* tt = expr_type (self->exp_t);
  type* ft = expr_type (self->exp_f);
  if (types_same (tt, ft)) // match is not enough
    return tt;
  else
    return type_unknown ();
}

expr_resolve_symbols (expr_if)
{
  expr_resolve_symbols (self->cond, block, log);
  expr_resolve_symbols (self->exp_t, block, log);
  expr_resolve_symbols (self->exp_f, block, log);
}




// ------------------------------------
//   ORDINARY EXPRESSION NODES
// ------------------------------------

%node expr_bin expression %abstract = {
  expression * left;
  expression * right;
}

/// Answer the string that represents the operator
%operation char const* expr_bin_op_str (expr_bin * self) = { NULL }

expr_to_str (expr_bin)
{
  buf = expr_to_str (self->left, buf);
  estr_prepend_cstr (buf, "(");
  estr_push (buf, ' ');
  estr_append_cstr (buf, expr_bin_op_str (self));
  estr_push (buf, ' ');
  estring_t * s = expr_to_str (self->right, NULL);
  estr_append (buf, s);
  estr_push (buf, ')');
  delete_estring (s);
  return buf;
}

expr_type (expr_bin)
{
  // @TODO: fixme
  return type_int ();
}

expr_resolve_symbols (expr_bin)
{
  expr_resolve_symbols (self->left, block, log);
  expr_resolve_symbols (self->right, block, log);
}


%node expr_aadd expr_bin = {}
expr_bin_op_str (expr_aadd) {return "+";}

%node expr_asub expr_bin = {}
expr_bin_op_str (expr_asub) {return "-";}

%node expr_amul expr_bin = {}
expr_bin_op_str (expr_amul) {return "*";}

%node expr_aidiv expr_bin = {}
expr_bin_op_str (expr_aidiv) {return "'div'";}

%node expr_ardiv expr_bin = {}
expr_bin_op_str (expr_ardiv) {return "/";}

%node expr_apow expr_bin = {}
expr_bin_op_str (expr_apow) {return "**";}


%node expr_rel expr_bin %abstract = {}
expr_type (expr_rel) { return type_bool (); }


%node expr_req expr_rel = {}
expr_bin_op_str (expr_req) {return "=";}

%node expr_rneq expr_rel = {}
expr_bin_op_str (expr_rneq) {return "!=";}

%node expr_rlt expr_rel = {}
expr_bin_op_str (expr_rlt) {return "<";}

%node expr_rlte expr_rel = {}
expr_bin_op_str (expr_rlte) {return "<=";}

%node expr_rgt expr_rel = {}
expr_bin_op_str (expr_rgt) {return ">";}

%node expr_rgte expr_rel = {}
expr_bin_op_str (expr_rgte) {return ">=";}


%node expr_log expr_bin %abstract = {}
expr_type (expr_log) { return type_bool (); }


%node expr_limp expr_log = {}
expr_bin_op_str (expr_limp) {return "=>";}

%node expr_leq expr_log = {}
expr_bin_op_str (expr_leq) {return "==";}

%node expr_lor expr_log = {}
expr_bin_op_str (expr_lor) {return "||";}

%node expr_land expr_log = {}
expr_bin_op_str (expr_land) {return "&&";}


%node expr_un expression %abstract = {
  expression * operand;
}

/// Answer the string that represents the operator
%operation char const* expr_un_op_str (expr_un * self) = { NULL }

expr_to_str (expr_un)
{
  buf = expr_to_str (self->operand, buf);
  estr_prepend_cstr (buf, expr_un_op_str (self));
  estr_prepend_cstr (buf, "(");
  estr_push (buf, ')');
  return buf;
}

expr_resolve_symbols (expr_un)
{
  expr_resolve_symbols (self->operand, block, log);
}

%node expr_uminus expr_un = {}
expr_un_op_str (expr_uminus) {return "-";}
expr_type (expr_uminus) {return expr_type (self->operand);}

%node expr_not expr_un = {}
expr_un_op_str (expr_not) {return "!";}
expr_type (expr_not) {return expr_type (self->operand);}




// ------------------------------------
//   FUNCALL NODE
// ------------------------------------

%node expr_call expression = {
  symbol * id;
  slist_t * arguments;
}

expr_to_str (expr_call)
{
  buf = symbol_to_str (self->id, buf);
  if (!slist_empty (self->arguments))
    {
      estr_push (buf, '(');
      slist_it_t * it = slist_iter (self->arguments);
      estring_t * tmp = new_estring ();
      while (1)
	{
	  expression * arg = slist_it_get (it);
	  tmp = expr_to_str (arg, tmp);
	  estr_append (buf, tmp);
	  slist_it_next (it);
	  if (!slist_it_has (it))
	    break;
	  estr_append_cstr (buf, ", ");
	}
      delete_slist_it (it);
      delete_estring (tmp);
      estr_push (buf, ')');
    }
  return buf;
}

expr_type (expr_call)
{
  // @TODO: fixme
  return type_int ();
}

expr_resolve_symbols (expr_call)
{
  container_find_name_rec_add_undefined (block, self->id, log);

  slist_it_t * it = slist_iter (self->arguments);
  for (; slist_it_has (it); slist_it_next (it))
    {
      expression * arg = slist_it_get (it);
      expr_resolve_symbols (arg, block, log);
    }
  delete_slist_it (it);
}


/*
 * Local Variables:
 * mode: c
 * c-syntactic-indentation: nil
 * End:
 */
