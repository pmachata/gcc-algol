// ------------------------------------
//   ROOT EXPRESSION NODE
// ------------------------------------

%node expression %abstract %typedef = {
}

/// Dump the expression to string.  Returns 'buf', or allocated buffer
/// if 'buf' was NULL.  Contents of non-NULL 'buf' is overwritten.
%operation estring_t * expr_to_str (expression * self, estring_t * buf) = { NULL }

/// Get the type of the expression.
%operation type * expr_type (expression * self) = { type_unknown () }

/// Resolve symbols used in this expression.  By the time this gets
/// called, symtabs should be already filled.  Typechecking should be
/// also performed here.
%operation void expr_resolve_symbols (expression * self, container * block, logger_t * log);



// ------------------------------------
//   INTEGER NUMBER NODE
// ------------------------------------

%node expr_int expression = {
  int value;
}

expr_to_str (expr_int)
{
  if (buf == NULL)
    buf = new_estring ();
  estr_printf (buf, "%d", self->value);
  return buf;
}

expr_type (expr_int)
{
  return type_int ();
}

expr_resolve_symbols (expr_int)
{
  // nothing
}



// ------------------------------------
//   REAL NUMBER NODE
// ------------------------------------

%node expr_real expression = {
  double value;
}

expr_to_str (expr_real)
{
  if (buf == NULL)
    buf = new_estring ();
  estr_printf (buf, "%f", self->value);
  return buf;
}

expr_type (expr_real)
{
  return type_real ();
}

expr_resolve_symbols (expr_real)
{
  // nothing
}




// ------------------------------------
//   STRING LITERAL NODE
// ------------------------------------

%node expr_string expression = {
  estring_t * value;
}

expr_to_str (expr_string)
{
  if (buf == NULL)
    buf = new_estring ();
  estr_assign (buf, self->value);
  return buf;
}

expr_type (expr_string)
{
  return type_string ();
}

expr_resolve_symbols (expr_string)
{
  // nothing
}



// ------------------------------------
//   BOOLEAN LITERAL NODE
// ------------------------------------

%node expr_bool expression = {
  int value;
}

expr_to_str (expr_bool)
{
  if (buf == NULL)
    buf = new_estring ();
  estr_assign_cstr (buf, self->value ? "'true'" : "'false'");
  return buf;
}

expr_type (expr_bool)
{
  return type_bool ();
}

expr_resolve_symbols (expr_bool)
{
  // nothing
}



// ------------------------------------
//   IDENTIFIER NODE
// ------------------------------------

%node expr_idref expression = {
  label * lbl;
  %nocreate symbol * sym = { NULL };
}

expr_to_str (expr_idref)
{
  return symbol_to_str (self->sym, buf);
}

expr_type (expr_idref)
{
  return self->sym->type;
}

expr_resolve_symbols (expr_idref)
{
  type * match_type = t_proc_create (type_any (), new_slist ());
  symbol * found = container_find_name_rec (block, self->lbl, match_type);
  if (found == NULL)
    found = container_find_name_rec_add_undefined (block, self->lbl, type_any (), log);
  self->sym = found;
}



// ------------------------------------
//   IF-EXPRESSION NODE
// ------------------------------------

%node expr_if expression = {
  expression * cond;
  expression * exp_t;
  expression * exp_f;
  %nocreate type * result_type = { NULL };
}

expr_to_str (expr_if)
{
  buf = expr_to_str (self->cond, buf);
  estr_prepend_cstr (buf, "'if' ");
  estr_append_cstr (buf, " 'then' ");
  estring_t * s = expr_to_str (self->exp_t, NULL);
  estr_append (buf, s);
  estr_append_cstr (buf, " 'else' ");
  expr_to_str (self->exp_f, s);
  estr_append (buf, s);
  delete_estring (s);
  return buf;
}

expr_type (expr_if)
{
  return self->result_type;
}

expr_resolve_symbols (expr_if)
{
  expr_resolve_symbols (self->cond, block, log);
  expr_resolve_symbols (self->exp_t, block, log);
  expr_resolve_symbols (self->exp_f, block, log);

  type* tt = expr_type (self->exp_t);
  type* ft = expr_type (self->exp_f);
  self->result_type = tt;
  if (!types_same (tt, ft)) // match is not enough
    {
      log_printf (log, ll_error, "both `if' branches have to have same types");
      self->exp_f = expr_primitive_for_type (tt);
    }
}




// ------------------------------------
//   ORDINARY EXPRESSION NODES
// ------------------------------------

%node expr_bin expression %abstract = {
  expression * left;
  expression * right;
}

/// Answer the string that represents the operator
%operation char const* expr_bin_op_str (expr_bin * self) = { NULL }

/// Answer the type of the binary expression
%operation type* expr_bin_type ([expr_bin * self], [type * ltype], [type * rtype]) = { NULL }


expr_to_str (expr_bin)
{
  buf = expr_to_str (self->left, buf);
  estr_prepend_cstr (buf, "(");
  estr_push (buf, ' ');
  estr_append_cstr (buf, expr_bin_op_str (self));
  estr_push (buf, ' ');
  estring_t * s = expr_to_str (self->right, NULL);
  estr_append (buf, s);
  estr_push (buf, ')');
  delete_estring (s);
  return buf;
}

expr_type (expr_bin)
{
  return expr_bin_type (self, expr_type (self->left), expr_type (self->right));
}


%node expr_arith expr_bin %abstract = {
}

%node expr_aadd expr_arith = {}
expr_bin_op_str (expr_aadd) {return "+";}

%node expr_asub expr_arith = {}
expr_bin_op_str (expr_asub) {return "-";}

%node expr_amul expr_arith = {}
expr_bin_op_str (expr_amul) {return "*";}

%node expr_aidiv expr_arith = {}
expr_bin_op_str (expr_aidiv) {return "'div'";}

%node expr_ardiv expr_arith = {}
expr_bin_op_str (expr_ardiv) {return "/";}

%node expr_apow expr_arith = {}
expr_bin_op_str (expr_apow) {return "**";}

expr_bin_type (expr_aadd, t_int, t_int),
expr_bin_type (expr_asub, t_int, t_int),
expr_bin_type (expr_amul, t_int, t_int),
expr_bin_type (expr_aidiv, t_int, t_int),
expr_bin_type (expr_apow, t_int, t_int)
{
  return type_int ();
}

expr_bin_type (expr_aadd, t_real, t_real),
expr_bin_type (expr_asub, t_real, t_real),
expr_bin_type (expr_amul, t_real, t_real),
expr_bin_type (expr_ardiv, t_int, t_int),
expr_bin_type (expr_ardiv, t_real, t_real)
{
  return type_real ();
}

expr_bin_type (expr_aadd, type, type),
expr_bin_type (expr_asub, type, type),
expr_bin_type (expr_amul, type, type),
expr_bin_type (expr_aidiv, type, type),
expr_bin_type (expr_ardiv, type, type),
expr_bin_type (expr_apow, type, type)
{
  return type_unknown ();
}

expr_resolve_symbols (expr_aadd),
expr_resolve_symbols (expr_asub),
expr_resolve_symbols (expr_amul),
expr_resolve_symbols (expr_aidiv),
expr_resolve_symbols (expr_ardiv),
expr_resolve_symbols (expr_apow),
expr_resolve_symbols (expr_bin)
{
  expr_resolve_symbols (self->left, block, log);
  expr_resolve_symbols (self->right, block, log);

  type* tt = expr_type (ast_as (expression, self));
  if (is_unknown (tt))
    {
      // @TODO: there should me some error recovery; this way our node
      // ends up being type_unknown, and avalanche of errors is
      // blurted on the user

      estring_t * es = expr_to_str (ast_as (expression, self), NULL);
      estring_t * tmp = type_to_str (expr_type (self->left), NULL);
      estr_prepend_cstr (es, "type mismatch in expression `");
      estr_append_cstr (es, "': ");
      estr_append (es, tmp);
      estr_push (es, ' ');
      estr_append_cstr (es, expr_bin_op_str (ast_as (expr_bin, self)));
      estr_push (es, ' ');
      type_to_str (expr_type (self->right), tmp);
      estr_append (es, tmp);

      log_printf (log, ll_error, "%s", estr_cstr (es));

      delete_estring (es);
      delete_estring (tmp);
    }
}


%node expr_rel expr_bin %abstract = {}


%node expr_req expr_rel = {}
expr_bin_op_str (expr_req) {return "=";}

%node expr_rneq expr_rel = {}
expr_bin_op_str (expr_rneq) {return "!=";}

%node expr_rlt expr_rel = {}
expr_bin_op_str (expr_rlt) {return "<";}

%node expr_rlte expr_rel = {}
expr_bin_op_str (expr_rlte) {return "<=";}

%node expr_rgt expr_rel = {}
expr_bin_op_str (expr_rgt) {return ">";}

%node expr_rgte expr_rel = {}
expr_bin_op_str (expr_rgte) {return ">=";}

expr_bin_type (expr_req, t_int, t_int),
expr_bin_type (expr_rneq, t_int, t_int),
expr_bin_type (expr_rlt, t_int, t_int),
expr_bin_type (expr_rlte, t_int, t_int),
expr_bin_type (expr_rgt, t_int, t_int),
expr_bin_type (expr_rgte, t_int, t_int),
expr_bin_type (expr_req, t_real, t_real),
expr_bin_type (expr_rneq, t_real, t_real),
expr_bin_type (expr_rlt, t_real, t_real),
expr_bin_type (expr_rlte, t_real, t_real),
expr_bin_type (expr_rgt, t_real, t_real),
expr_bin_type (expr_rgte, t_real, t_real)
{
  return type_bool ();
}

expr_bin_type (expr_req, type, type),
expr_bin_type (expr_rneq, type, type),
expr_bin_type (expr_rlt, type, type),
expr_bin_type (expr_rlte, type, type),
expr_bin_type (expr_rgt, type, type),
expr_bin_type (expr_rgte, type, type)
{
  return type_unknown ();
}



%node expr_log expr_bin %abstract = {}
expr_type (expr_log) { return type_bool (); }


%node expr_limp expr_log = {}
expr_bin_op_str (expr_limp) {return "=>";}

%node expr_leq expr_log = {}
expr_bin_op_str (expr_leq) {return "==";}

%node expr_lor expr_log = {}
expr_bin_op_str (expr_lor) {return "||";}

%node expr_land expr_log = {}
expr_bin_op_str (expr_land) {return "&&";}


expr_bin_type (expr_limp, t_bool, t_bool),
expr_bin_type (expr_leq, t_bool, t_bool),
expr_bin_type (expr_lor, t_bool, t_bool),
expr_bin_type (expr_land, t_bool, t_bool)
{
  return type_bool ();
}

expr_bin_type (expr_limp, type, type),
expr_bin_type (expr_leq, type, type),
expr_bin_type (expr_lor, type, type),
expr_bin_type (expr_land, type, type)
{
  return type_unknown ();
}


%node expr_un expression %abstract = {
  expression * operand;
}

/// Answer the string that represents the operator
%operation char const* expr_un_op_str (expr_un * self) = { NULL }

expr_to_str (expr_un)
{
  buf = expr_to_str (self->operand, buf);
  estr_prepend_cstr (buf, expr_un_op_str (self));
  estr_prepend_cstr (buf, "(");
  estr_push (buf, ')');
  return buf;
}

expr_resolve_symbols (expr_un)
{
  expr_resolve_symbols (self->operand, block, log);
}

%node expr_uminus expr_un = {}
expr_un_op_str (expr_uminus) {return "-";}
expr_type (expr_uminus) {return expr_type (self->operand);}

%node expr_not expr_un = {}
expr_un_op_str (expr_not) {return "!";}
expr_type (expr_not) {return expr_type (self->operand);}




// ------------------------------------
//   FUNCALL NODE
// ------------------------------------

%node expr_call expression = {
  label * lbl;
  slist_t * arguments;
  %nocreate type * t = { NULL };
  %nocreate symbol * sym = { NULL };
}

expr_to_str (expr_call)
{
  buf = label_to_str (self->lbl, buf);
  if (!slist_empty (self->arguments))
    {
      estr_push (buf, '(');
      slist_it_t * it = slist_iter (self->arguments);
      estring_t * tmp = new_estring ();
      while (1)
	{
	  expression * arg = slist_it_get (it);
	  tmp = expr_to_str (arg, tmp);
	  estr_append (buf, tmp);
	  slist_it_next (it);
	  if (!slist_it_has (it))
	    break;
	  estr_append_cstr (buf, ", ");
	}
      delete_slist_it (it);
      delete_estring (tmp);
      estr_push (buf, ')');
    }
  return buf;
}

expr_type (expr_call)
{
  return ast_as (t_proc, self->sym->type)->ret_type;
}

expr_resolve_symbols (expr_call)
{
  slist_t * argtypes = new_slist ();
  slist_it_t * it = slist_iter (self->arguments);
  for (; slist_it_has (it); slist_it_next (it))
    {
      expression * arg = slist_it_get (it);
      expr_resolve_symbols (arg, block, log);
      type * argtype = expr_type (arg);
      slist_pushback (argtypes, argtype);
    }
  delete_slist_it (it);

  type * match_type = t_proc_create (type_any (), argtypes);
  self->sym = container_find_name_rec_add_undefined (block, self->lbl, match_type, log);
  delete_slist (argtypes);
}


/*
 * Local Variables:
 * mode: c
 * c-syntactic-indentation: nil
 * End:
 */
