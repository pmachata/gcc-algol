// ------------------------------------
//   ROOT EXPRESSION NODE
// ------------------------------------

%node expression %abstract %typedef = {
}

/// Dump the expression to string.  Returns 'buf', or allocated buffer
/// if 'buf' was NULL.  Contents of non-NULL 'buf' is overwritten.
%operation estring_t * expr_to_str (expression * self, estring_t * buf) = { NULL }

/// Get the type of the expression.
%operation type_t const* expr_type (expression * self) = { type_unknown () }



// ------------------------------------
//   INTEGER NUMBER NODE
// ------------------------------------

%node expr_int expression = {
  int value;
}

expr_to_str (expr_int)
{
  if (buf == NULL)
    buf = new_estring ();
  estr_printf (buf, "%d", self->value);
  return buf;
}

expr_type (expr_int)
{
  return type_int ();
}



// ------------------------------------
//   REAL NUMBER NODE
// ------------------------------------

%node expr_real expression = {
  double value;
}

expr_to_str (expr_real)
{
  if (buf == NULL)
    buf = new_estring ();
  estr_printf (buf, "%f", self->value);
  return buf;
}

expr_type (expr_real)
{
  return type_real ();
}




// ------------------------------------
//   STRING LITERAL NODE
// ------------------------------------

%node expr_string expression = {
  estring_t * value;
}

expr_to_str (expr_string)
{
  if (buf == NULL)
    buf = new_estring ();
  estr_assign (buf, self->value);
  return buf;
}

expr_type (expr_string)
{
  return type_string ();
}




// ------------------------------------
//   IDENTIFIER NODE
// ------------------------------------

%node expr_idref expression = {
  symbol * sym;
}

expr_to_str (expr_idref)
{
  return symbol_to_str (self->sym, buf);
}

expr_type (expr_idref)
{
  return self->sym->type;
}

/*
 * Local Variables:
 * mode: c
 * c-syntactic-indentation: nil
 * End:
 */
