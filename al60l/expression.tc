// ------------------------------------
//   ROOT EXPRESSION NODE
// ------------------------------------

%node expression %abstract %typedef = {
}

/// Dump the expression to string.  Returns 'buf', or allocated buffer
/// if 'buf' was NULL.  Contents of non-NULL 'buf' is overwritten.
%operation estring_t * expr_to_str (expression * self, estring_t * buf) = { NULL }

/// Get the type of the expression.
%operation type_t const* expr_type (expression * self) = { type_unknown () }



// ------------------------------------
//   INTEGER NUMBER NODE
// ------------------------------------

%node expr_int expression = {
  int value;
}

expr_to_str (expr_int)
{
  if (buf == NULL)
    buf = new_estring ();
  estr_printf (buf, "%d", self->value);
  return buf;
}

expr_type (expr_int)
{
  return type_int ();
}



// ------------------------------------
//   REAL NUMBER NODE
// ------------------------------------

%node expr_real expression = {
  double value;
}

expr_to_str (expr_real)
{
  if (buf == NULL)
    buf = new_estring ();
  estr_printf (buf, "%f", self->value);
  return buf;
}

expr_type (expr_real)
{
  return type_real ();
}




// ------------------------------------
//   STRING LITERAL NODE
// ------------------------------------

%node expr_string expression = {
  estring_t * value;
}

expr_to_str (expr_string)
{
  if (buf == NULL)
    buf = new_estring ();
  estr_assign (buf, self->value);
  return buf;
}

expr_type (expr_string)
{
  return type_string ();
}




// ------------------------------------
//   IDENTIFIER NODE
// ------------------------------------

%node expr_idref expression = {
  symbol * sym;
}

expr_to_str (expr_idref)
{
  return symbol_to_str (self->sym, buf);
}

expr_type (expr_idref)
{
  return self->sym->type;
}




// ------------------------------------
//   IF-EXPRESSION NODE
// ------------------------------------

%node expr_if expression = {
  expression * cond;
  expression * exp_t;
  expression * exp_f;
}

expr_to_str (expr_if)
{
  buf = expr_to_str (self->cond, buf);
  estr_prepend_cstr (buf, "'if' ");
  estr_append_cstr (buf, " 'then' ");
  estring_t * s = expr_to_str (self->exp_t, NULL);
  estr_append (buf, s);
  estr_append_cstr (buf, " 'else' ");
  expr_to_str (self->exp_f, s);
  estr_append (buf, s);
  delete_estring (s);
  return buf;
}

expr_type (expr_if)
{
  type_t const* tt = expr_type (self->exp_t);
  type_t const* ft = expr_type (self->exp_f);
  if (types_same (tt, ft)) // match is not enough
    return tt;
  else
    return type_unknown ();
}




// ------------------------------------
//   ORDINARY EXPRESSION NODES
// ------------------------------------

%node expr_bin expression %abstract = {
  expression * left;
  expression * right;
}

/// Answer the string that represents the operator
%operation char const* expr_bin_op_str (expr_bin * self) = { NULL }

expr_to_str (expr_bin)
{
  buf = expr_to_str (self->left, buf);
  estr_prepend_cstr (buf, "(");
  estr_push (buf, ' ');
  estr_append_cstr (buf, expr_bin_op_str (self));
  estr_push (buf, ' ');
  estring_t * s = expr_to_str (self->right, NULL);
  estr_append (buf, s);
  estr_push (buf, ')');
  delete_estring (s);
  return buf;
}

expr_type (expr_bin)
{
  // @TODO: fixme
  return type_int ();
}


%node expr_aadd expr_bin = {}
expr_bin_op_str (expr_aadd) {return "+";}

%node expr_asub expr_bin = {}
expr_bin_op_str (expr_asub) {return "-";}

%node expr_amul expr_bin = {}
expr_bin_op_str (expr_amul) {return "*";}

%node expr_aidiv expr_bin = {}
expr_bin_op_str (expr_aidiv) {return "'div'";}

%node expr_ardiv expr_bin = {}
expr_bin_op_str (expr_ardiv) {return "/";}

%node expr_apow expr_bin = {}
expr_bin_op_str (expr_apow) {return "**";}


%node expr_rel expr_bin %abstract = {}
expr_type (expr_rel) { return type_bool (); }


%node expr_req expr_rel = {}
expr_bin_op_str (expr_req) {return "=";}

%node expr_rneq expr_rel = {}
expr_bin_op_str (expr_rneq) {return "!=";}

%node expr_rlt expr_rel = {}
expr_bin_op_str (expr_rlt) {return "<";}

%node expr_rlte expr_rel = {}
expr_bin_op_str (expr_rlte) {return "<=";}

%node expr_rgt expr_rel = {}
expr_bin_op_str (expr_rgt) {return ">";}

%node expr_rgte expr_rel = {}
expr_bin_op_str (expr_rgte) {return ">=";}


%node expr_log expr_bin %abstract = {}
expr_type (expr_log) { return type_bool (); }


%node expr_limp expr_log = {}
expr_bin_op_str (expr_limp) {return "=>";}

%node expr_leq expr_log = {}
expr_bin_op_str (expr_leq) {return "==";}

%node expr_lor expr_log = {}
expr_bin_op_str (expr_lor) {return "||";}

%node expr_land expr_log = {}
expr_bin_op_str (expr_land) {return "&&";}


%node expr_un expression %abstract = {
  expression * operand;
}

/// Answer the string that represents the operator
%operation char const* expr_un_op_str (expr_un * self) = { NULL }

expr_to_str (expr_un)
{
  buf = expr_to_str (self->operand, buf);
  estr_prepend_cstr (buf, expr_un_op_str (self));
  estr_prepend_cstr (buf, "(");
  estr_push (buf, ')');
  return buf;
}

%node expr_uminus expr_un = {}
expr_un_op_str (expr_uminus) {return "-";}
expr_type (expr_uminus) {return expr_type (self->operand);}

%node expr_not expr_un = {}
expr_un_op_str (expr_not) {return "!";}
expr_type (expr_not) {return expr_type (self->operand);}

/*
 * Local Variables:
 * mode: c
 * c-syntactic-indentation: nil
 * End:
 */
